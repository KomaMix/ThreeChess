<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess for Three - Игровая доска</title>
    <link rel="stylesheet" href="/styles/board.css?v=1.0" />
</head>
<body>

    <svg width="800" height="800" viewBox="0 0 800 800" alignment-baseline="central">
        <g id="cells-layer"></g>
        <g id="labels-layer"></g>
        <g id="figures-layer"></g>
    </svg>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/6.0.1/signalr.js"></script>
    <script>
        const boardElementsState = {
            cells: {}
        };

        const movedElements = {
            diagonals: {},
            mainLines: {},
            secondaryLines: {}
        };

        let last_click_id = undefined;

        const hubConnection = new signalR.HubConnectionBuilder()
            .withUrl("/move")
            .build();


        hubConnection.on("Receive", function (id) {
            try {
                document.querySelectorAll('path').forEach(path => {
                    if (path.getAttribute('data-cell-id') === id.toString()) {
                        path.classList.add('cell-highlighted');
                    }
                });
            } catch (error) {
                console.error('Error in Receive handler:', error);
            }
        });


        const VIEWBOX_SIZE = 800;
        const CENTER_OFFSET = 400;

        async function loadCells() {
            try {
                const [cellsResponse,
                    figuresResponse,
                    diagonalsResponse,
                    mainLinesResponse,
                    secondaryLinesResponse] = await Promise.all([
                    fetch('/api/cells-location'),
                    fetch('/api/figures-location'),
                    fetch('/api/diagonals'),
                    fetch('/api/main-lines'),
                    fetch('/api/secondary-lines')
                ]);

                const cells = await cellsResponse.json();
                const figuresMap = await figuresResponse.json();
                const diagonals = await diagonalsResponse.json();
                const mainLines = await mainLinesResponse.json();
                const secondaryLines = await secondaryLinesResponse.json();

                console.log("Клетки:", cells);
                console.log("Фигуры:", figuresMap);
                console.log("Диагонали:", diagonals);
                console.log("Главные линии:", mainLines);

                movedElements.diagonals = diagonals;
                movedElements.mainLines = mainLines;
                movedElements.secondaryLines = secondaryLines;
                

                renderBoard(cells, figuresMap);
            } catch (error) {
                console.error('Error:', error);
            }
        }

        function renderBoard(cells, figuresMap) {
            const cellsLayer = document.getElementById('cells-layer');
            const labelsLayer = document.getElementById('labels-layer');
            const figuresLayer = document.getElementById('figures-layer');

            // Очищаем все слои
            cellsLayer.innerHTML = '';
            labelsLayer.innerHTML = '';
            figuresLayer.innerHTML = '';


            cells.forEach(cell => {
                if (!validatePolygon(cell.polygon.points)) return;

                // Масштабирование точек
                const scaledPoints = cell.polygon.points.map(p => ({
                    x: p.x * VIEWBOX_SIZE / 2 + CENTER_OFFSET,
                    y: p.y * VIEWBOX_SIZE / 2 + CENTER_OFFSET
                }));

                // Создание пути
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', generatePathData(scaledPoints));
                path.setAttribute('data-cell-id', cell.id);

                if (cell.isWhite) {
                    path.classList.add('cell-white');
                } else {
                    path.classList.add('cell-black');
                }

                path.addEventListener('click', async () => {
                    try {
                        console.log('Clicked cell:', cell.id, 'Last clicked:', last_click_id);

                        // Если это первый клик
                        if (last_click_id === undefined) {
                            // Если в ячейке есть фигура
                            if (boardElementsState.cells[cell.id].elements.figure) {
                                clearHighlightedCells();

                                const piece = boardElementsState.cells[cell.id].elements.figure;
                                // Проверяем тип фигуры (сравнение с ожидаемыми строковыми значениями, например 'Queen' или 'Bishop')
                                if (piece.figureInfo.figureType === 'Queen'
                                    || piece.figureInfo.figureType === 'Bishop'
                                    || piece.figureInfo.figureType === 'King') {
                                    // Выделяем диагональные ячейки, доступные для хода
                                    highlightDiagonalMoves(cell.id, piece.figureInfo.figureType);
                                }

                                if (piece.figureInfo.figureType === 'Queen'
                                    || piece.figureInfo.figureType == 'Rook'
                                    || piece.figureInfo.figureType === 'King') {
                                    highlightMainLinesMoves(cell.id, piece.figureInfo.figureType);
                                }

                                if (piece.figureInfo.figureType === 'Queen'
                                    || piece.figureInfo.figureType == 'Rook'
                                    || piece.figureInfo.figureType === 'King') {
                                    highlightSecondaryLinesMoves(cell.id, piece.figureInfo.figureType);
                                }
                                last_click_id = cell.id;
                            }
                        }
                        // Если это второй клик
                        else {
                            if (last_click_id !== cell.id) {
                                clearHighlightedCells();
                                moveFigure(last_click_id, cell.id);
                                last_click_id = undefined;
                            }
                        }
                    } catch (err) {
                        console.error("Error sending cell click:", err);
                    }
                });


                const centroid = {
                    x: cell.center.x * VIEWBOX_SIZE / 2 + CENTER_OFFSET,
                    y: cell.center.y * VIEWBOX_SIZE / 2 + CENTER_OFFSET,
                };

                const figureInfo = figuresMap[cell.id.toString()];

                let figureImage = undefined;
                if (figureInfo) {
                    figureImage = document.createElementNS('http://www.w3.org/2000/svg', 'image');
                    figureImage.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', figureInfo.path);
                    figureImage.setAttribute('x', centroid.x - 25);
                    figureImage.setAttribute('y', centroid.y - 25);
                    figureImage.setAttribute('width', '50');
                    figureImage.setAttribute('height', '50');
                    figureImage.classList.add('cell-figure');
                }
                
                

                let labelText; 
                labelText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                labelText.setAttribute('x', centroid.x);
                labelText.setAttribute('y', centroid.y);
                labelText.textContent = cell.id;
                labelText.classList.add('cell-label');

                if (figureInfo) {
                    labelText.style.visibility = 'hidden';
                }
                

                boardElementsState.cells[cell.id] = {
                    id: cell.id,
                    center: { x: centroid.x, y: centroid.y },
                    elements: {
                        path: path,
                        figure: figureInfo ? {
                            figureImage: figureImage || null,
                            figureInfo: figureInfo
                        } : null,
                        label: labelText
                    }
                };


                cellsLayer.appendChild(path);
                if (figureInfo) {
                    figuresLayer.appendChild(figureImage);
                }
                
                labelsLayer.appendChild(labelText);

            });

            console.log("State:", boardElementsState);
        }

        function moveFigure(startId, endId) {
            console.log('Attempt to move from', startId, 'to', endId);

            const cellFrom = boardElementsState.cells[startId];
            const cellTo = boardElementsState.cells[endId];

            


            if (!cellFrom || !cellTo) {
                console.error('Cells not found');
                return;
            }

            // Если в исходной ячейке нет фигуры
            if (!cellFrom.elements.figure) {
                console.log('No figure in source cell');
                return;
            }

            // Переносим фигуру
            if (cellTo.elements.figure) {
                console.log('Target cell occupied');
                return;
            }

            // Обновляем DOM
            cellTo.elements.figure = cellFrom.elements.figure;
            cellFrom.elements.figure = null;

            cellFrom.elements.label.style.visibility = 'visible';
            cellTo.elements.label.style.visibility = 'hidden';

            // Позиционируем фигуру в новой ячейке
            cellTo.elements.figure.figureImage.setAttribute('x', cellTo.center.x - 25);
            cellTo.elements.figure.figureImage.setAttribute('y', cellTo.center.y - 25);

            console.log('Moved successfully');
        }

        function generatePathData(points) {
            let path = `M${points[0].x},${points[0].y}`;
            for (let i = 1; i < points.length; i++) {
                path += ` L${points[i].x},${points[i].y}`;
            }
            return `${path} Z`;
        }

        function validatePolygon(points) {
            if (points.length < 3) return false;
            const first = points[0];
            const last = points[points.length - 1];
            if (first.x !== last.x || first.y !== last.y) {
                points.push({ ...first });
            }
            return true;
        }

        function clearHighlightedCells() {
            document.querySelectorAll('path').forEach(path => {
                path.classList.remove('cell-highlighted');
            });
        }

        function highlightDiagonalMoves(cellId, figureType) {
            isKing = false;

            if (figureType === 'King') {
                isKing = true;
            }

            // Получаем массив диагоналей из глобального состояния
            const diagonals = movedElements.diagonals; // предполагается, что это массив массивов строк

            // Фильтруем только те диагонали, в которых присутствует текущая ячейка
            const relevantDiagonals = diagonals.filter(diagonal => diagonal.includes(cellId));

            console.log("relevantDiagonals:", relevantDiagonals);

            relevantDiagonals.forEach(diagonal => {
                const currentIndex = diagonal.indexOf(cellId);

                // Проходим в сторону начала диагонали
                for (let i = currentIndex - 1; i >= 0; i--) {
                    const targetCellId = diagonal[i];
                    const cell = boardElementsState.cells[targetCellId];
                    if (!cell) break;
                    // Если в ячейке есть фигура, выделяем её (как потенциальное взятие) и прекращаем поиск в этом направлении
                    if (cell.elements.figure) {
                        cell.elements.path.classList.add('cell-highlighted');
                        console.log(`added light ${targetCellId}`);
                        break;
                    } else {
                        cell.elements.path.classList.add('cell-highlighted');
                        console.log(`added light ${targetCellId}`);
                    }

                    if (isKing) {
                        break;
                    }
                }

                // Проходим в сторону конца диагонали
                for (let i = currentIndex + 1; i < diagonal.length; i++) {
                    const targetCellId = diagonal[i];
                    const cell = boardElementsState.cells[targetCellId];
                    if (!cell) break;
                    if (cell.elements.figure) {
                        cell.elements.path.classList.add('cell-highlighted');
                        break;
                    } else {
                        cell.elements.path.classList.add('cell-highlighted');
                    }

                    if (isKing) {
                        break;
                    }
                }
            });
        }

        function highlightMainLinesMoves(cellId, figureType) {
            isKing = false;

            if (figureType === 'King') {
                isKing = true;
            }

            // Получаем массив диагоналей из глобального состояния
            const mainLines = movedElements.mainLines; // предполагается, что это массив массивов строк

            // Фильтруем только те диагонали, в которых присутствует текущая ячейка
            const relevantLines = mainLines.filter(line => line.includes(cellId));

            console.log("relevantLines:", relevantLines);

            relevantLines.forEach(line => {
                const currentIndex = line.indexOf(cellId);

                // Проходим в сторону начала диагонали
                for (let i = currentIndex - 1; i >= 0; i--) {
                    const targetCellId = line[i];
                    const cell = boardElementsState.cells[targetCellId];
                    if (!cell) break;
                    // Если в ячейке есть фигура, выделяем её (как потенциальное взятие) и прекращаем поиск в этом направлении
                    if (cell.elements.figure) {
                        cell.elements.path.classList.add('cell-highlighted');
                        console.log(`added light ${targetCellId}`);
                        break;
                    } else {
                        cell.elements.path.classList.add('cell-highlighted');
                        console.log(`added light ${targetCellId}`);
                    }

                    if (isKing) {
                        break;
                    }
                }

                // Проходим в сторону конца диагонали
                for (let i = currentIndex + 1; i < line.length; i++) {
                    const targetCellId = line[i];
                    const cell = boardElementsState.cells[targetCellId];
                    if (!cell) break;
                    if (cell.elements.figure) {
                        cell.elements.path.classList.add('cell-highlighted');
                        break;
                    } else {
                        cell.elements.path.classList.add('cell-highlighted');
                    }

                    if (isKing) { 
                        break;
                    }
                }
            });
        }

        function highlightSecondaryLinesMoves(cellId, figureType) {
            isKing = false;

            if (figureType === 'King') {
                isKing = true;
            }

            // Получаем массив диагоналей из глобального состояния
            const secondaryLines = movedElements.secondaryLines; // предполагается, что это массив массивов строк

            // Фильтруем только те диагонали, в которых присутствует текущая ячейка
            const relevantLines = secondaryLines.filter(line => line.includes(cellId));

            console.log("relevantLines:", relevantLines);

            relevantLines.forEach(line => {
                const currentIndex = line.indexOf(cellId);

                // Проходим в сторону начала диагонали
                for (let i = currentIndex - 1; i >= 0; i--) {
                    const targetCellId = line[i];
                    const cell = boardElementsState.cells[targetCellId];
                    if (!cell) break;
                    // Если в ячейке есть фигура, выделяем её (как потенциальное взятие) и прекращаем поиск в этом направлении
                    if (cell.elements.figure) {
                        cell.elements.path.classList.add('cell-highlighted');
                        console.log(`added light ${targetCellId}`);
                        break;
                    } else {
                        cell.elements.path.classList.add('cell-highlighted');
                        console.log(`added light ${targetCellId}`);
                    }

                    if (isKing) {
                        break;
                    }
                }

                // Проходим в сторону конца диагонали
                for (let i = currentIndex + 1; i < line.length; i++) {
                    const targetCellId = line[i];
                    const cell = boardElementsState.cells[targetCellId];
                    if (!cell) break;
                    if (cell.elements.figure) {
                        cell.elements.path.classList.add('cell-highlighted');
                        break;
                    } else {
                        cell.elements.path.classList.add('cell-highlighted');
                    }

                    if (isKing) {
                        break;
                    }
                }
            });
        }

        

        window.addEventListener('DOMContentLoaded', loadCells);
        hubConnection.start()
            .then(function () {
                
            })
            .catch(function (err) {
                return console.error(err.toString());
            });
    </script>

</body>
</html>