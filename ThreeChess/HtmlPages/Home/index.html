<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess for Three - Игровая доска</title>
    <link rel="stylesheet" href="/styles/board.css?v=1.0" />
</head>
<body>

    <svg width="800" height="800" viewBox="0 0 800 800" alignment-baseline="central">
        <g id="cells-layer"></g>
        <g id="labels-layer"></g>
        <g id="figures-layer"></g>
    </svg>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/6.0.1/signalr.js"></script>
    <script src="/scripts/moveHandler.js?v=1.9"></script>
    <script src="/scripts/loadCells.js?v=1.0"></script>
    <script src="/scripts/validatePolygon.js?v=1.0"></script>
    <script>
        const VIEWBOX_SIZE = 800;
        const CENTER_OFFSET = 400;

        const boardElementsState = {
            cells: {}
        };

        const movedElements = {
            diagonals: {},
            mainLines: {},
            secondaryLines: {}
        };

        let last_click_id = undefined;

        const hubConnection = new signalR.HubConnectionBuilder()
            .withUrl("/move")
            .build();


        hubConnection.on("Receive", function (id) {
            try {
                document.querySelectorAll('path').forEach(path => {
                    if (path.getAttribute('data-cell-id') === id.toString()) {
                        path.classList.add('cell-highlighted');
                    }
                });
            } catch (error) {
                console.error('Error in Receive handler:', error);
            }
        });


        function renderBoard(cells, figuresMap) {
            const cellsLayer = document.getElementById('cells-layer');
            const labelsLayer = document.getElementById('labels-layer');
            const figuresLayer = document.getElementById('figures-layer');

            // Очищаем все слои
            cellsLayer.innerHTML = '';
            labelsLayer.innerHTML = '';
            figuresLayer.innerHTML = '';


            cells.forEach(cell => {
                if (!validatePolygon(cell.polygon.points)) return;

                // Масштабирование точек
                const scaledPoints = cell.polygon.points.map(p => ({
                    x: p.x * VIEWBOX_SIZE / 2 + CENTER_OFFSET,
                    y: p.y * VIEWBOX_SIZE / 2 + CENTER_OFFSET
                }));

                // Создание пути
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', generatePathData(scaledPoints));
                path.setAttribute('data-cell-id', cell.id);

                if (cell.isWhite) {
                    path.classList.add('cell-white');
                } else {
                    path.classList.add('cell-black');
                }

                path.addEventListener('click', async () => {
                    try {
                        console.log('Clicked cell:', cell.id, 'Last clicked:', last_click_id);

                        const cellTo = boardElementsState.cells[cell.id];

                        // Если это первый клик
                        if (last_click_id === undefined || cellTo.elements.figure) {
                            // Если в ячейке есть фигура
                            if (boardElementsState.cells[cell.id].elements.figure) {
                                clearHighlightedCells();

                                const piece = boardElementsState.cells[cell.id].elements.figure;
                                // Проверяем тип фигуры (сравнение с ожидаемыми строковыми значениями, например 'Queen' или 'Bishop')
                                if (piece.figureInfo.figureType === 'Queen'
                                    || piece.figureInfo.figureType === 'Bishop'
                                    || piece.figureInfo.figureType === 'King') {
                                    // Выделяем диагональные ячейки, доступные для хода
                                    highlightDiagonalMoves(cell.id, piece.figureInfo.figureType);
                                }

                                if (piece.figureInfo.figureType === 'Queen'
                                    || piece.figureInfo.figureType == 'Rook'
                                    || piece.figureInfo.figureType === 'King') {
                                    highlightMainLinesMoves(cell.id, piece.figureInfo.figureType);
                                }

                                if (piece.figureInfo.figureType === 'Queen'
                                    || piece.figureInfo.figureType == 'Rook'
                                    || piece.figureInfo.figureType === 'King') {
                                    highlightSecondaryLinesMoves(cell.id, piece.figureInfo.figureType);
                                }

                                if (piece.figureInfo.figureType === 'Knight') {
                                    highlightKnightMoves(cell.id);
                                }

                                if (piece.figureInfo.figureType === 'Pawn') {
                                    highlightPawnMoves(cell.id);
                                }

                                last_click_id = cell.id;
                            }
                        }
                        // Если это второй клик
                        else {
                            if (last_click_id !== cell.id) {
                                const cellTo = boardElementsState.cells[cell.id];

                                clearHighlightedCells();

                                moveFigure(last_click_id, cell.id);
                                last_click_id = undefined;
                            }
                        }
                    } catch (err) {
                        console.error("Error sending cell click:", err);
                    }
                });


                const centroid = {
                    x: cell.center.x * VIEWBOX_SIZE / 2 + CENTER_OFFSET,
                    y: cell.center.y * VIEWBOX_SIZE / 2 + CENTER_OFFSET,
                };

                const figureInfo = figuresMap[cell.id.toString()];

                let figureImage = undefined;
                if (figureInfo) {
                    figureImage = document.createElementNS('http://www.w3.org/2000/svg', 'image');
                    figureImage.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', figureInfo.path);
                    figureImage.setAttribute('x', centroid.x - 25);
                    figureImage.setAttribute('y', centroid.y - 25);
                    figureImage.setAttribute('width', '50');
                    figureImage.setAttribute('height', '50');
                    figureImage.classList.add('cell-figure');
                }



                let labelText;
                labelText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                labelText.setAttribute('x', centroid.x);
                labelText.setAttribute('y', centroid.y);
                labelText.textContent = cell.id;
                labelText.classList.add('cell-label');

                if (figureInfo) {
                    labelText.style.visibility = 'hidden';
                }


                boardElementsState.cells[cell.id] = {
                    id: cell.id,
                    center: { x: centroid.x, y: centroid.y },
                    elements: {
                        path: path,
                        figure: figureInfo ? {
                            figureImage: figureImage || null,
                            figureInfo: figureInfo
                        } : null,
                        label: labelText
                    }
                };


                cellsLayer.appendChild(path);
                if (figureInfo) {
                    figuresLayer.appendChild(figureImage);
                }

                labelsLayer.appendChild(labelText);

            });

            console.log("State:", boardElementsState);
        }

        function moveFigure(startId, endId) {
            console.log('Attempt to move from', startId, 'to', endId);

            const cellFrom = boardElementsState.cells[startId];
            const cellTo = boardElementsState.cells[endId];

            if (!cellFrom || !cellTo) {
                console.error('Cells not found');
                return;
            }

            // Если в исходной ячейке нет фигуры
            if (!cellFrom.elements.figure) {
                console.log('No figure in source cell');
                return;
            }

            const figure = cellFrom.elements.figure;

            // Если фигура является пешкой, проверяем, прошла ли она половину доски.
            // Для этого ищем главную линию, в которой находится ячейка и смотрим индексы.
            if (figure.figureInfo.figureType === 'Pawn') {
                for (let line of movedElements.mainLines) {
                    const startIndex = line.indexOf(startId);
                    const endIndex = line.indexOf(endId);
                    // Если обе ячейки принадлежат одной и той же главной линии
                    if (startIndex !== -1 && endIndex !== -1) {
                        // Если пешка переходила между индексами 3 и 4 (в любом направлении)
                        if ((startIndex === 3 && endIndex === 4) || (startIndex === 4 && endIndex === 3)) {
                            figure.hasPassedHalfBoard = true;
                            console.log('Pawn has passed half board.');
                        }
                        break;
                    }
                }
            }

            // Переносим фигуру, если целевая клетка пуста
            if (cellTo.elements.figure) {
                console.log('Target cell occupied');
                return;
            }

            // Обновляем DOM: перемещаем фигуру из одной ячейки в другую
            cellTo.elements.figure = figure;
            cellFrom.elements.figure = null;

            cellFrom.elements.label.style.visibility = 'visible';
            cellTo.elements.label.style.visibility = 'hidden';

            // Позиционируем фигуру в новой ячейке
            cellTo.elements.figure.figureImage.setAttribute('x', cellTo.center.x - 25);
            cellTo.elements.figure.figureImage.setAttribute('y', cellTo.center.y - 25);

            console.log('Moved successfully');
        }

        function generatePathData(points) {
            let path = `M${points[0].x},${points[0].y}`;
            for (let i = 1; i < points.length; i++) {
                path += ` L${points[i].x},${points[i].y}`;
            }
            return `${path} Z`;
        }


        window.addEventListener('DOMContentLoaded', loadCells);
        hubConnection.start()
            .then(function () {

            })
            .catch(function (err) {
                return console.error(err.toString());
            });
    </script>

</body>
</html>