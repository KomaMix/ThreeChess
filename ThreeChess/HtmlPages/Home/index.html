<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess for Three - Игровая доска</title>
    <link rel="stylesheet" href="/styles/board.css" />
</head>
<body>

    <svg width="800" height="800" viewBox="0 0 800 800" alignment-baseline="central">
        <g id="cells-layer"></g>
        <g id="labels-layer"></g>
        <g id="figures-layer"></g>
    </svg>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/6.0.1/signalr.js"></script>
    <script>
        const state = {
            cells: {}
        };

        let last_click_id = undefined;

        const hubConnection = new signalR.HubConnectionBuilder()
            .withUrl("/move")
            .build();


        hubConnection.on("Receive", function (id) {
            try {
                document.querySelectorAll('path').forEach(path => {
                    if (path.getAttribute('data-cell-id') === id.toString()) {
                        path.classList.add('cell-highlighted');
                    }
                });
            } catch (error) {
                console.error('Error in Receive handler:', error);
            }
        });


        const VIEWBOX_SIZE = 800;
        const CENTER_OFFSET = 400;

        async function loadCells() {
            try {
                const [cellsResponse, figuresResponse] = await Promise.all([
                    fetch('/api/cells-location'),
                    fetch('/api/figures-location')
                ]);

                const cells = await cellsResponse.json();
                const figuresMap = await figuresResponse.json();

                console.log(cells);
                console.log(figuresMap);
                

                renderBoard(cells, figuresMap);
            } catch (error) {
                console.error('Error:', error);
            }
        }

        function renderBoard(cells, figuresMap) {
            const cellsLayer = document.getElementById('cells-layer');
            const labelsLayer = document.getElementById('labels-layer');
            const figuresLayer = document.getElementById('figures-layer');

            // Очищаем все слои
            cellsLayer.innerHTML = '';
            labelsLayer.innerHTML = '';
            figuresLayer.innerHTML = '';


            cells.forEach(cell => {
                if (!validatePolygon(cell.polygon.points)) return;

                // Масштабирование точек
                const scaledPoints = cell.polygon.points.map(p => ({
                    x: p.x * VIEWBOX_SIZE / 2 + CENTER_OFFSET,
                    y: p.y * VIEWBOX_SIZE / 2 + CENTER_OFFSET
                }));

                // Создание пути
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', generatePathData(scaledPoints));
                path.setAttribute('data-cell-id', cell.id);

                if (cell.isWhite) {
                    path.classList.add('cell-white');
                } else {
                    path.classList.add('cell-black');
                }

                path.addEventListener('click', async () => {
                    try {
                        console.log('Clicked cell:', cell.id, 'Last clicked:', last_click_id);

                        // Если это первый клик
                        if (last_click_id === undefined) {
                            // Проверяем есть ли фигура в ячейке
                            if (state.cells[cell.id].elements.figure) {
                                last_click_id = cell.id;
                            }
                        }
                        // Если это второй клик
                        else {
                            // Выполняем перемещение
                            moveFigure(last_click_id, cell.id);

                            last_click_id = undefined;
                        }
                    } catch (err) {
                        console.error("Error sending cell click:", err);
                    }
                });


                const centroid = {
                    x: cell.center.x * VIEWBOX_SIZE / 2 + CENTER_OFFSET,
                    y: cell.center.y * VIEWBOX_SIZE / 2 + CENTER_OFFSET,
                };

                const figurePath = figuresMap[cell.id.toString()];

                let figureImage = undefined;
                if (figurePath) {
                    figureImage = document.createElementNS('http://www.w3.org/2000/svg', 'image');
                    figureImage.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', figurePath);
                    figureImage.setAttribute('x', centroid.x - 25);
                    figureImage.setAttribute('y', centroid.y - 25);
                    figureImage.setAttribute('width', '50');
                    figureImage.setAttribute('height', '50');
                    figureImage.classList.add('cell-figure');
                }
                
                

                let labelText; 
                labelText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                labelText.setAttribute('x', centroid.x);
                labelText.setAttribute('y', centroid.y);
                labelText.textContent = cell.id;
                labelText.classList.add('cell-label');

                if (figurePath) {
                    labelText.style.visibility = 'hidden';
                }


                state.cells[cell.id] = {
                    id: cell.id,
                    center: { x: centroid.x, y: centroid.y },
                    elements: {
                        path: path,
                        figure: figureImage || null,
                        label: labelText
                    }
                };


                cellsLayer.appendChild(path);
                if (figurePath) {
                    figuresLayer.appendChild(figureImage);
                }
                
                labelsLayer.appendChild(labelText);

            });
        }

        function moveFigure(startId, endId) {
            console.log('Attempt to move from', startId, 'to', endId);

            const cellFrom = state.cells[startId];
            const cellTo = state.cells[endId];

            


            if (!cellFrom || !cellTo) {
                console.error('Cells not found');
                return;
            }

            // Если в исходной ячейке нет фигуры
            if (!cellFrom.elements.figure) {
                console.log('No figure in source cell');
                return;
            }

            // Переносим фигуру
            if (cellTo.elements.figure) {
                console.log('Target cell occupied');
                return;
            }

            // Обновляем DOM
            cellTo.elements.figure = cellFrom.elements.figure;
            cellFrom.elements.figure = null;

            cellFrom.elements.label.style.visibility = 'visible';
            cellTo.elements.label.style.visibility = 'hidden';

            // Позиционируем фигуру в новой ячейке
            cellTo.elements.figure.setAttribute('x', cellTo.center.x - 25);
            cellTo.elements.figure.setAttribute('y', cellTo.center.y - 25);

            console.log('Moved successfully');
        }

        function generatePathData(points) {
            let path = `M${points[0].x},${points[0].y}`;
            for (let i = 1; i < points.length; i++) {
                path += ` L${points[i].x},${points[i].y}`;
            }
            return `${path} Z`;
        }

        function validatePolygon(points) {
            if (points.length < 3) return false;
            const first = points[0];
            const last = points[points.length - 1];
            if (first.x !== last.x || first.y !== last.y) {
                points.push({ ...first });
            }
            return true;
        }

        window.addEventListener('DOMContentLoaded', loadCells);
        hubConnection.start()
            .then(function () {
                
            })
            .catch(function (err) {
                return console.error(err.toString());
            });
    </script>

</body>
</html>